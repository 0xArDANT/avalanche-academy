---
title: Setting Incentives
description: Learn about the basics of Avalanche.
updated: 2024-06-09
authors: [andyvargtz]
icon: Book
---

As we studied in previous lessons, the sendCrossChainMessage function takes TeleporterMessageInput struct as an input. The fields feeInfo in the TeleporterMessageInput will be a TeleporterFeeInfo struct formed by the ERC20 contract address in which the fee will be paid, as well as the amount of tokens to incentivize the relayer. This amount needs to be set in wei units. Let's take a look at it:

```solidity
// (c) 2023, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem

pragma solidity 0.8.18;

struct TeleporterMessageInput {
    bytes32 destinationBlockchainID;
    address destinationAddress;
    TeleporterFeeInfo feeInfo;
    uint256 requiredGasLimit;
    address[] allowedRelayerAddresses;
    bytes message;
}

struct TeleporterFeeInfo {
    address contractAddress;
    uint256 amount;
}

interface ITeleporterMessenger {
    function sendCrossChainMessage(TeleporterMessageInput calldata messageInput)
        external
    returns (bytes32);
}
```

A contract implementing fees should look like this: 

Notice, our contract implementing Fees now needs to include the functionality we described in the fee flow section:

- Import IERC20 and create the fee contract interface instance 
- ðŸ“œThe Cross-Subnet dApp transfers the ERC20 fee amount to the control of the Cross-Chain dApp contract. (Line 19)
- ðŸ“œCross-Subnet dApp needs to implement the approval for the Teleporter contract of these ERC20 tokens (Line 21-24)
- Include the TeleporterFeeInfo struct in the message. (Lines: 30-33)

```solidity
// (c) 2023, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem

pragma solidity 0.8.18;

import "https://github.com/ava-labs/teleporter/blob/main/contracts/src/Teleporter/ITeleporterMessenger.sol";
import {IERC20} from "@openzeppelin/contracts@4/token/ERC20/IERC20.sol";

contract SenderWithFeesOnSource {

    ITeleporterMessenger public immutable teleporterMessenger = ITeleporterMessenger(0x253b2784c75e510dD0fF1da844684a1aC0aa5fcf);

    function sendMessage(address destinationAddress, string memory message_to_send, address erc20_address) external returns (uint256) {
      IERC20 feeContract = IERC20(erc20_address); // [!code highlight]
      uint256 feeAmount = <fee_amount>; // [!code highlight]
      feeContract.transferFrom(msg.sender, address(this), feeAmount);

      feeContract.approve( // [!code highlight]
          address(teleporterMessenger), // [!code highlight]
          feeAmount // [!code highlight]
      );
      
      return teleporterMessenger.sendCrossChainMessage(
        TeleporterMessageInput({
          destinationChainID: <destination_chain>,
          destinationAddress: <destinationAddress>,
          feeInfo: TeleporterFeeInfo({
            feeTokenAddress: erc20_address, // [!code highlight]
            amount: feeAmount
            }),
          requiredGasLimit: <required_gas_limit>,
          allowedRelayerAddresses: new address[](0),
          message: abi.encode(message_to_send)
          })
      );
    }
}
```